# -*- ispell-dictionary: "english" -*-


#+AUTHOR: David √Ålvarez Rosa
#+EMAIL: david@alvarezrosa.com
#+STARTUP: showall


* LiDAR Compensation üö®

This repository contains the source code of the =LiDAR= Compensation.


** Getting Started üöÄ
These instructions will get you a copy of the project up and running on your
local machine for development and testing purposes.

*** Prerequisites üìã
Robot Operating System (=ROS=) needs to be installed ([[http://wiki.ros.org/kinetic/Installation/Ubuntu][link]]) and a =rosbag= with
raw data is needed.
#+BEGIN_SRC bash
  ros-kinetic-desktop-full
#+END_SRC

*** Installing üîß
The folders given are =ROS= packages that need to be inside your workspace
following this structure:
#+BEGIN_SRC text
  your-ws
    build
    devel
    src
      lidar-compensation
         imgs
         include
         launch
         ...
#+END_SRC

Then, the steps are:

*Create workspace and src folder*
#+BEGIN_SRC bash
  mkdir your-ws
  cd your-ws
  mkdir src
  catkin_make
#+END_SRC

*Clone the repository inside src*
#+BEGIN_SRC bash
  cd src
  git clone git@serv-driverless-33:david.alvarez/lidar-compensation.git
#+END_SRC

*Compile the code (it may take some time the first time)*
#+BEGIN_SRC bash
  cd ..
  catkin_make
#+END_SRC


** Running the algorithm with raw data ‚öôÔ∏è
*Launch the nodelet*
#+BEGIN_SRC bash
  source devel/setup.bash
  roslaunch lidar-compensation LidarCompensation.launch
#+END_SRC

Then, the =nodelet= is waiting for the input data.

*Play the rosbag:*
#+BEGIN_SRC bash
  cd <folder_with_rosbags>
  rosrun rqt_bag rqt_bag rosbag_name.bag
#+END_SRC
and publish the =velodyne_points= topic.

or
#+BEGIN_SRC bash
  cd <folder_with_rosbags>
  rosbag play rosbag_name.bag --loop
#+END_SRC
and all the topics in the =rosbags= will be published.
The =nodelet= should start computing and printing results.

*** Visualization üîÆ
Use =RVIZ= to visualize the point cloud and the markers published with the cones
detected:
#+BEGIN_SRC bash
  rviz &
#+END_SRC
and add type of data =PointCloud2= and =MarkerArray=.


** Understanding the code üí°
The main purpose of this code is to compensate the distortion that appears in
the data received from the =LiDAR= due to the movement of the car. This happens
because the =LiDAR= takes non-zero time for completing a turn. Therefore, since
information is return for each full turn, position will be distorted due to the
car movement.

At slow (car) speeds this effect is not noticeable, however at higher speeds
correcting this distortion can be crucial for a correct perception of the
surrounding environment.

For fixing ideas, let's suppose that the =LiDAR= is rotating at a frequency of
*10Hz* and that the car is going (in a straight line) at *25m/s* (90km/h). Then,
there may be points such that the detection time differs by *0.1s* (i.e. a
period). Therefore, by this time the car will have moved (and the =LiDAR= with
it) *2.5m* (0.1s * 25m/s). This is the actual (maximum) distortion.

*** Get velocity from IMU üå™
We get the (linear) velocity of the car at that moment from a =IMU=.
#+BEGIN_SRC c++
  geometry_msgs::Vector3 velocity = odom->twist.twist.linear;
#+END_SRC

*** First angle of vision üìê
Obviously, there is not such a thing like the distortion of a complete
=PointCloud=, since it will be different for each point. This distortion
depends on the time between the recording of the first point and the current
one. This elapsed time is proportional to the difference of angles between
points, therefore we will work with angles since they can be more easily
computed.

The first angle of vision *Œ∏‚ÇÄ* is computed as follows:
#+BEGIN_SRC c++
  pcl::PointXYZ& point0 = cloud.points[0];
  float theta0 = atan(-point0.y, point0.x);
#+END_SRC

*** Actual compensation üìù
For compensating a =PointCloud= we iterate on points and for each point we do
the following.

+ Compute it's angle *Œ∏*: same as previous section computation.
+ Compute the differences in angles (known *Œ∏* and *Œ∏‚ÇÄ*):
#+BEGIN_SRC c++
  float deltaTheta = theta0 - theta;
    if (deltaTheta < 0)
      deltaTheta += 2 * M_PI;
#+END_SRC
+ Compute elapsed time (known the =LiDAR= frequency and the difference between
  angles):
#+BEGIN_SRC c++
  float time = deltaTheta / ( 2 * M_PI * FREQUENCY );
#+END_SRC
+ Compensate point (known elapsed time and linear velocity of the car):
#+BEGIN_SRC c++
  point.x += time * velocity.x;
  point.y += time * velocity.y;
  point.z += time * velocity.z;
#+END_SRC


** Results üéØ
We will know present some examples of the compensation code in operation. In all
the examples below the linear velocity of the car is shown in the open terminal
in the top left corner (in km/h). The =LiDAR= frequency in all this examples is
fixed and set to *10Hz*. In the images are shown both the non-compensated filter
=PointCloud= and the compensated:
+ _Non-compensated_: *colored* points.
+ _Compensated_: *white* points.

*** Acceleration ‚¨Ü
This is an (straight) acceleration test at a moderate speed (around *35km/h*).
#+HTML: <img src="imgs/1. Acceleration.png" width="100%" />
As you can see the compensation works as expected. The cones are being "pushed
back" always (as it should be) and cones pairs line up.
*** Faster acceleration ‚¨Ü
Here is another example of an (straight) acceleration test at a higher speed
(around *75km/h*) and with a larger field of vision.
#+HTML: <img src="imgs/2. Faster acceleration.png" width="100%" />
One thing to note is that the first left cone is "alone" because the distortion
is large enough not to see it's partner.
*** Lateral compensation in acceleration ‚Üó
This is also another example of an (straight) acceleration test, but in this
case the car is not centered on the track and it's turning right to center
it.
#+HTML: <img src="imgs/3. Lateral compensation in acceleration.png" width="100%" />
We can see here the lateral compensation (more accentuated in the cones on
the right).
*** No compensation - Slow speed üêå
Here is an example in which the car is going at a slow speed (around
*4km/h*).
#+HTML: <img src="imgs/4. No compensation - Slow speed.png" width="100%" />
As we can see there is no appreciable compensation, as expected.
*** Curved road üîÑ
Finally, an example of compensation on a curved road.
#+HTML: <img src="imgs/5. Curved road.png" width="100%" />


** Difficulties üõ†
Ask a Perception member ;)


** Authors ‚úíÔ∏è
David √Ålvarez Rosa
